import { spawn, execSync, spawnSync } from "node:child_process";
import {
    writeFileSync,
    existsSync,
    mkdirSync,
    createWriteStream,
    chmodSync,
} from "node:fs";
import { join } from "node:path";
import { pipeline } from "node:stream/promises";
import { PELAUT_DIR, LOGS_DIR, conf, ensureDirs } from "./config.js";
import * as store from "./store.js";
import { getRunningPort, getVariants } from "./process-manager.js";
import { serverDomain } from "./git.js";

const CADDYFILE = join(PELAUT_DIR, "Caddyfile");
const CADDY_LOG = join(LOGS_DIR, "caddy.log");
const CADDY_BIN_DIR = join(PELAUT_DIR, "bin");
const CADDY_BIN = join(CADDY_BIN_DIR, "caddy");
const CADDY_TRUSTED_MARKER = join(PELAUT_DIR, ".caddy-trusted");

let caddyProcess = null;

// â”€â”€ Binary Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function findCaddyBin() {
    if (existsSync(CADDY_BIN)) return CADDY_BIN;
    try {
        return execSync("which caddy", {
            encoding: "utf-8",
            stdio: ["pipe", "pipe", "pipe"],
        }).trim();
    } catch {
        return null;
    }
}

function getCaddyDownloadUrl() {
    const arch = process.arch === "arm64" ? "arm64" : "amd64";
    const os = process.platform === "darwin" ? "darwin" : "linux";
    return `https://caddyserver.com/api/download?os=${os}&arch=${arch}`;
}

async function downloadCaddy() {
    console.log("  ðŸ“¦ Downloading Caddy...");
    if (!existsSync(CADDY_BIN_DIR)) mkdirSync(CADDY_BIN_DIR, { recursive: true });

    const res = await fetch(getCaddyDownloadUrl(), { redirect: "follow" });
    if (!res.ok) throw new Error(`Failed to download Caddy: ${res.status}`);

    await pipeline(res.body, createWriteStream(CADDY_BIN));
    chmodSync(CADDY_BIN, 0o755);
    console.log(`  âœ“ Caddy downloaded to ${CADDY_BIN}`);
}

export async function ensureCaddy() {
    const bin = findCaddyBin();
    if (bin) return bin;
    await downloadCaddy();
    return CADDY_BIN;
}

// â”€â”€ Trust â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function trustCaddy() {
    const bin = await ensureCaddy();
    console.log("  ðŸ” Installing Caddy root CA into system trust store...");
    console.log("     (you may be prompted for your password)\n");
    spawnSync(bin, ["trust"], { stdio: "inherit" });
    writeFileSync(CADDY_TRUSTED_MARKER, new Date().toISOString());
}

export function isTrusted() {
    return existsSync(CADDY_TRUSTED_MARKER);
}

// â”€â”€ Caddyfile Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Generate a Caddyfile from the current server list and running ports.
 * Supports env subdomain variants: myapp.sg.localhost, myapp.us.localhost, etc.
 */
export function generateCaddyfile() {
    ensureDirs();

    const servers = store.list();
    const tld = conf.tld || "localhost";
    const apiPort = conf.apiPort || 2001;

    let caddyfile = `# Auto-generated by pelaut â€” do not edit manually
{
  local_certs
  admin localhost:2019
}

# â”€â”€ Pelaut Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
localhost:${conf.port} {
  reverse_proxy 127.0.0.1:${apiPort}
}

`;

    for (const srv of servers) {
        const variants = getVariants(srv);
        const baseDomain = serverDomain(srv, tld);

        if (variants.length > 0) {
            // Server has env subdomain variants â€” one Caddy block per variant
            // Extract base parts for variant domain construction
            const domainParts = baseDomain.split(".");
            const domainBase = domainParts[0]; // may include worktree subdomain
            const domainTld = domainParts.slice(1).join(".");

            for (const v of variants) {
                // Insert variant before the tld: myapp.feat-login.sg.localhost
                const variantDomain = `${domainBase}.${v.variant}.${domainTld}`;
                const port = getRunningPort(srv.name, v.variant);
                const envLabel = Object.entries(v.envOverrides)
                    .map(([k, val]) => `${k}=${val}`)
                    .join(", ");

                if (port) {
                    caddyfile += `# â”€â”€ ${srv.name} (${envLabel}) â”€â”€\n${variantDomain} {\n  reverse_proxy 127.0.0.1:${port}\n}\n\n`;
                } else {
                    caddyfile += `# â”€â”€ ${srv.name}.${v.variant} (stopped) â”€â”€\n${variantDomain} {\n  respond "Server '${srv.name}' variant '${v.variant}' is not running." 503\n}\n\n`;
                }
            }
        } else {
            // Normal server (or worktree without env variants)
            const port = getRunningPort(srv.name);
            if (port) {
                caddyfile += `# â”€â”€ ${srv.name} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n${baseDomain} {\n  reverse_proxy 127.0.0.1:${port}\n}\n\n`;
            } else {
                caddyfile += `# â”€â”€ ${srv.name} (stopped) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n${baseDomain} {\n  respond "Server '${srv.name}' is not running. Start it via the Pelaut dashboard." 503\n}\n\n`;
            }
        }
    }

    writeFileSync(CADDYFILE, caddyfile);
    return CADDYFILE;
}

// â”€â”€ Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function startCaddy() {
    const bin = await ensureCaddy();

    if (!isTrusted()) await trustCaddy();

    generateCaddyfile();
    if (!existsSync(LOGS_DIR)) mkdirSync(LOGS_DIR, { recursive: true });

    const logStream = createWriteStream(CADDY_LOG, { flags: "a" });

    caddyProcess = spawn(bin, ["run", "--config", CADDYFILE], {
        stdio: ["ignore", "pipe", "pipe"],
        detached: false,
    });

    caddyProcess.stdout.on("data", (data) => logStream.write(data));
    caddyProcess.stderr.on("data", (data) => logStream.write(data));

    caddyProcess.on("error", (err) => {
        console.error(`  Caddy error: ${err.message}`);
    });

    caddyProcess.on("exit", (code) => {
        if (code !== null && code !== 0) console.error(`  Caddy exited with code ${code}`);
        caddyProcess = null;
        logStream.end();
    });

    return caddyProcess;
}

export function reloadCaddy() {
    if (!caddyProcess) return;
    generateCaddyfile();
    const bin = findCaddyBin();
    if (!bin) return;
    try {
        execSync(`"${bin}" reload --config "${CADDYFILE}"`, {
            stdio: ["pipe", "pipe", "pipe"],
        });
    } catch (err) {
        console.error(`  Caddy reload failed: ${err.message}`);
    }
}

export function stopCaddy() {
    if (caddyProcess) {
        caddyProcess.kill("SIGTERM");
        caddyProcess = null;
    }
}

export function isCaddyRunning() {
    return caddyProcess !== null && !caddyProcess.killed;
}

export { CADDYFILE, CADDY_LOG, CADDY_BIN };
